\documentclass[a4paper,11pt]{article}

%\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{polyglossia}
\usepackage{amsmath}
%\usepackage[parfill]{parskip}

\setmainfont[Ligatures=TeX]{Noto Serif}
\newfontfamily\cyrillicfont[Script=Cyrillic]{Noto Serif}

\setmainlanguage{bulgarian}
\PolyglossiaSetup{bulgarian}{indentfirst=false}

\setlength{\parindent}{2em}
\setlength{\parskip}{0em}

\title{Tape}
\author{Александър Кръстев}
\date{Август 2017}

\begin{document}
\maketitle
\section{Задача}
\subsection{Условие}
За тази задача трябва да напишете две програми, които да работят заедно.

\textit{А} разполага с лента, съставена от $N$ клетки, като във всяка записва 
$1$ или $0$ (един бит).

\textit{Б} започва в някаква неизвестна за \textit{А} и \textit{Б} клетка и 
трябва да разбере в коя 
(клетките са номерирани $0, 1,...,N-1$ от ляво надясно). 
За целта \textit{Б} може да се предвижва до съседната си вдясно клетка си 
(знае дали има такава) 
и вижда записаната от \textit{А} стойност във всяка клетка, която посети. 
Разполага и със стойността на $N$.

\subsection{Тестване}
За всеки тест \textit{А} се изпълнява веднъж, но \textit{Б} се изпълнява до
$1000$ пъти - записаните стойности от \textit{А} не се променят, но варира 
началната позиция на \textit{Б}. Задачата се оценява адаптивно, т.е. оценяващата
програма ще избира началните позиции, за които да тества \textit{Б}, спрямо 
кодирането на лентата, получено от \textit{А}.

\subsection{Оценяване}
Тестовете са разделени на групи. Нека означим с $Q$ максималния брой разрешени 
придвижвания на Вашата програма \textit{Б} за дадена група. 
\begin{enumerate}
\setlength\itemsep{0em}
 \item (10 точки) $N \leq 1\ 000$, $Q \leq 5\ 000$
 \item (10 точки) $N \leq 1\ 000\ 000$, $Q \leq 5\ 000$
 \item (10 точки) $N \leq 1\ 000\ 000$, $Q \leq 100$
 \item (10 точки) $N \leq 1\ 000\ 000$, $Q \leq 70$
 \item (10 точки) $N \leq 1\ 000\ 000$, $Q \leq 50$
 \item (50 точки) $N \leq 1\ 000\ 000$, $Q \leq 50$;
 Нека означим с $C$ максималния максималния брой придвижвания, направени от 
 Вашата програма за \textit{Б}. Точките Ви се определят по формулата
 $min(50, 50 \times \frac{50 - C}{29})$.

\end{enumerate}

\section{Решение}
В анализа ще означаваме с $Q$ максималния брой придвижвания на \textit{Б} за
даден алгоритъм.

Щом \textit{Б} намери индекса на посетена от нея клетка, \textit{Б} може да
намери и индекса на началната, вадейки броя на придвижванията до клетката с
известен индекс.
Затова алгоритмите долу описват само как да се намери индекса на една от
посетените клетки.

\subsection{Теоретичен минимум}
Полезно е наблюдението, че с по-малко от $\lceil \log_2{N} \rceil $ бита
информация
(т.е $\lceil \log_2{N} \rceil- 1$ придвижвания)
\textit{Б} не може да намери всяка стартова позиция: 
Броят стартови позиции би бил по-голям от броя на конфигурациите от битове,
видени от \textit{Б}.
Следователно на поне една двойка начални позиции би съответствала една и съща
конфигурация.
Следователно тези две начални позиции биха били неразличими.
От тук следва, че за всеки алгоритъм $Q \geq \lceil \log_2{N} \rceil - 1$
(преместванията са с $1$ по-малко от прочетените битове).

\section{Алгоритми с $Q > O(\log{N})$}
\subsection{$Q=N$}
\textit{А} може да не записва нищо по лентата.
\textit{Б} се движи надясно до края на лентата, намирайки клетка с номер $N$. 
Този алгоритъм преминава \textit{подзадача 1}.
\subsection{$Q=2\times \lceil \sqrt{N} \rceil - 1$}
\textit{А} записва първо един бит $1$ и един $0$, след това два бита $1$,
следвани от два $0$ и т.н. до $\lceil \sqrt{N} \rceil$ бита $1$ и $0$.
Нека всяка такава последователност от еднакви символи наричаме сегмент. 

Първо \textit{Б} се движи надясно до края на началния сегмент - всеки край на
сегмент се характеризира с два съседни, различни по стойност бита.
След това \textit{Б} продължава до края на следващия сегмент и така намира
неговата дължина.
Алгоритъмът обхожда най-много два цели сегмента, съставени от най-много 
$2 \times \lceil \sqrt{N} \rceil$ клетки и съответно 
$Q = 2 \times \lceil \sqrt{N} \rceil - 1$.
Тази информация е достатъчна на Б, за да намери индекса на началото на втория
сегмент.

Един начин да се постигне това е като се обхождат сегментите в реда, в който са
записани от \textit{А} и се сумират дължините им.
Началният индекс на текущия сегмент е равен на сумата от дължините на
предхождащите го сегменти.
Този алгоритъм е линеен по броя на сегментите и съответно $O(\log{N})$.  

\end{document}
